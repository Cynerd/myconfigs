// vim:ft=javascript
require("theme.js");
theme_load_paths.unshift("~/.conkeror/");
theme_unload("default");
theme_load("theme");

require("session.js");
session_auto_save_auto_load = true;

require("favicon.js");
require("new-tabs.js");
tab_bar_show_icon = true;
tab_bar_show_index = false;

require("clicks-in-new-buffer.js");

require("opensearch.js");
define_opensearch_webjump("?", "duckduckgo.xml");
define_opensearch_webjump("?g", "google.xml");
define_opensearch_webjump("?w", "wikipedia.xml");
define_opensearch_webjump("?e", "eBay.xml");

external_content_handlers.set("application/pdf", "okular");
external_content_handlers.set("video/*", "vlc");
editor_shell_command = "urxvt -e vim";

url_completion_use_history = true;
url_remoting_fn = load_url_in_new_buffer;
download_buffer_automatic_open_target = OPEN_NEW_BUFFER_BACKGROUND;

require("adblockplus.js");

// Set zoom to 90%
session_pref("layout.css.devPixelsPerPx", "0.9");

// Just key-kill all websites. I can use quote mode (ctrl+q)
require("key-kill");
key_kill_mode.test.push(/\/\/.*\//); //regexp matches all sites

view_source_use_external_editor = true;

// Set cwd to ~/downloads so that downloads are saved there
cwd = get_home_directory();
cwd.append("downloads");

/////////////////////////////////////////////////////////////////////////////////
// reopening closed buffers
define_key(default_global_keymap, "A-W", "revive-buffer");

// Save origin kill_buffer command
var kill_buffer_original = kill_buffer_original || kill_buffer;

var killed_buffer_urls = [];
var killed_buffer_histories = [];

//  remember_killed_buffer
kill_buffer = function (buffer, force) {
    var hist = buffer.web_navigation.sessionHistory;

    if (buffer.display_uri_string && hist) {
        killed_buffer_histories.push(hist);
        killed_buffer_urls.push(buffer.display_uri_string);
    }

    kill_buffer_original(buffer,force);
};

interactive("revive-buffer",
    "Loads url from a previously killed buffer",
    function restore_killed_buffer (I) {
        if (killed_buffer_urls.length !== 0) {
            var url = yield I.minibuffer.read(
                $prompt = "Restore killed url:",
                $completer = new all_word_completer($completions = killed_buffer_urls),
                $default_completion = killed_buffer_urls[killed_buffer_urls.length - 1],
                $auto_complete = "url",
                $auto_complete_initial = true,
                $auto_complete_delay = 0,
                $require_match = true);

            var window = I.window;
            var creator = buffer_creator(content_buffer);
            var idx = killed_buffer_urls.indexOf(url);

            // Create the buffer
            var buf = creator(window, null);

            // Recover the history
            buf.web_navigation.sessionHistory = killed_buffer_histories[idx];

            // This line may seem redundant, but it's necessary.
            var original_index = buf.web_navigation.sessionHistory.index;
            buf.web_navigation.gotoIndex(original_index);

            // Focus the new tab
            window.buffers.current = buf;

            // Remove revived from cemitery
            killed_buffer_urls.splice(idx,1);
            killed_buffer_histories.splice(idx,1);
        } else {
            I.window.minibuffer.message("No killed buffer urls");
        }
    });
/////////////////////////////////////////////////////////////////////////////////
// pass password management
define_key(default_global_keymap, "C-j", "pass-get-name");
define_key(default_global_keymap, "C-J", "pass-get-password");

// Extract first and second domain by this hack
function get_domain(I) {
	var domain = I.buffer.document.location.href;
	var tmp_a = I.buffer.document.createElement('a');
	tmp_a.href = domain;
	domain = tmp_a.hostname.match(/[^.]+\.[^.]+$/);
	yield co_return(domain);
}

function shell(cmd, input) {
	var res = {
		stdout: "",
		stderr: "",
		result: 0
	};
	res.result = yield shell_command(cmd,
					 $fds = [{ output: async_binary_string_writer(input) },
							 { input: async_binary_reader(function (s) res.stdout+=s||"") },
							 { input: async_binary_reader(function (s) res.stderr+=s||"") }
							]
					);
	yield co_return(res);
};

var pass_domain = "";
var pass_account = "";

function pass_chose_account(I) {
	pass_domain = yield get_domain(I);
	var res = yield shell("cd ~/.password-store && find -path '*" + pass_domain + "*' -type f", "");
	var accs = res.stdout.split('\n');
	if (accs.length == 0 || accs.length == 1) {
		I.window.minibuffer.message("pass: No accounts detected for domain: " + pass_domain);
		pass_account = "";
		return;
	// Note that accs has empty line at end so all this is bumped by one
	} else if (accs.length == 2) {
		pass_account = accs[0].replace(/\.\//, '').replace(/\.gpg$/, '');
	} else {
		var accs_list = [];
		for (i = 0; i < accs.length - 1; i++) {
			accs_list.push(accs[i].replace(/\.\//, '').replace(/\.gpg$/, ''));
		}
		pass_account = yield I.minibuffer.read(
			$prompt = "Chose account for " + pass_domain + ":",
			$completer = new all_word_completer($completions = accs_list),
			$default_completion = accs_list[accs_list.length - 1],
			$auto_complete = "url",
			$auto_complete_initial = true,
			$auto_complete_delay = 0,
			$require_match = true);
	}
}

function pass_get_password(I) {
	var domain = yield get_domain(I);
	if (pass_account == "" || String(pass_domain) != String(domain)) {
		yield pass_chose_account(I);
	}
	if (pass_account != "" && I.buffer.focused_element) {
		var res = yield shell("pass " + pass_account, "");
		dumpln(res.stdout);
		I.buffer.focused_element.value = res.stdout;
		I.window.minibuffer.message("pass: Inserted password for account: " + pass_account);
		pass_account = ""; // remove selected account so we can select new one
	}
};

function pass_get_name(I) {
	yield pass_chose_account(I);
	I.window.minibuffer.message("pass: Chosen account: " + pass_account);
	if (I.buffer.focused_element){
		var regexp = /[^\/]*$/;
		I.buffer.focused_element.value = regexp.exec(pass_account)[0];
	}
};

interactive("pass-get-name", "Choses account for to be loged as. As result name of account is outputed.", pass_get_name);
interactive("pass-get-password", "Receives password from pass for currently selected account.", pass_get_password);
/////////////////////////////////////////////////////////////////////////////////
